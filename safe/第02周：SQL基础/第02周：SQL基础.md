# 信安之路

- [信安之路](#%e4%bf%a1%e5%ae%89%e4%b9%8b%e8%b7%af)
    - [第02周](#%e7%ac%ac02%e5%91%a8)
    - [前言](#%e5%89%8d%e8%a8%80)
    - [1.概念（推荐）](#1%e6%a6%82%e5%bf%b5%e6%8e%a8%e8%8d%90)
        - [1.1.关系型数据库](#11%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93)
            - [1.1.1.代表](#111%e4%bb%a3%e8%a1%a8)
            - [1.1.2.特性](#112%e7%89%b9%e6%80%a7)
            - [1.1.3.不足](#113%e4%b8%8d%e8%b6%b3)
        - [1.2.非关系型数据库](#12%e9%9d%9e%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93)
            - [1.2.1.特性](#121%e7%89%b9%e6%80%a7)
                - [CA](#ca)
                - [CP](#cp)
                - [AP](#ap)
            - [1.2.2.代表](#122%e4%bb%a3%e8%a1%a8)
    - [2.MySQL基础](#2mysql%e5%9f%ba%e7%a1%80)
        - [2.1.](#21)
    - [3.SQLServer基础](#3sqlserver%e5%9f%ba%e7%a1%80)

## 第02周

Code：<https://github.com/lotapp/BaseCode/tree/master/safe>

## 前言

本周需要自行研究学习的任务贴一下：

![目标](https://img2018.cnblogs.com/blog/1127869/201908/1127869-20190806185807094-2024433233.png)

## 1.概念（推荐）

### 1.1.关系型数据库

引用百科的一段`抽象`描述：
> “关系型数据库，是指**采用了关系模型**来组织数据的数据库，其**以行和列的形式存储数据**，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。关系模型可以简单理解为二维表格模型，而一个关系型数据库就是由二维表及其之间的关系组成的一个数据组织。”

通俗讲就是：**现实中的东西抽象成一个个关系，然后存储在一张张行列组成的表中，这些表就组成了关系型数据库**
> PS：重点就是各数据之间的`关系`（Join）

#### 1.1.1.代表

最经典的莫过于：**`MySQL`**、`SQLServer`、`PostgreSQL`、**`SQLite`**、`Oracle`

#### 1.1.2.特性

先看看传统数据库的好处：

1. 通过事务保持数据一致
2. 可以Join等复杂查询
3. 社区完善（遇到问题简单搜下就ok了）

最典型的特征就是：**事物的ACID特性**
> PS：抽象的就不说了，举个例子来说明`ACID`：

1. A：**原子性**（Atomic）
    - 小明转账1000给小张：小明-=1000 => 小张+=1000，这个 **（事务）是一个不可分割的整体**，如果小明-1000后出现问题，那么1000得退给小明
    - PS：化学里面原子的定义是啥? ==> `化学反应不可再分的基本微粒`
2. C：**一致性**（Consistent）
    - 小明转账1000给小张，必须保证小明+小张的**总额不变**（假设不受其他转账(事务)影响）
    - PS：可以用初三化学中的`能量守恒`来理解
3. I：**隔离性**（Isolated）
    - 小明转账给小张的同时，小潘也转钱给了小张，需要保证他们**相互不影响**（主要是并发情况下的隔离）
    - PS：理想各个`国家互不干涉内政`
4. D：**持久性**（Durable）
    - 小明转账给小张，银行要**留有记录**，即使以后扯皮也可以拉流水账【事务执行成功后进行的持久化（就算数据库之后挂了也能通过Log恢复）】
    - PS：理想银行每次`交易留的底单`，这个就是持久化的表现

#### 1.1.3.不足

1. **修改表结构**（包括建立索引）**导致长时间不能更新数据**（上了表锁）
2. **列不固定**时新增或删除表很繁琐（同样面临表锁的问题）
    - PS：一般设计数据库不可能那么完善，都是后期越来越完善，就算自己预留了`保留字段`也容易因为预留名的不确定性容易出错
3. **简单查询不能快速返回**（需要先解析SQL，然后还有诸如表进行加锁解锁这些额外开销，然后才能查找）
4. **大量数据写入**比较麻烦
    1. 数据量不大还好，批量写入即可
    2. 可是本身数据量就挺大的，进行了`主从复制`，读数据在`Salver`进行到没啥事，但是大量写数据库怼到`Master`上去就吃不消了，必须得加主数据库了。
    3. 加完又出问题了：虽然把主数据库一分为二，但是容易发生`数据不一致`（同样数据在两个主数据库更新成不一样的值），这时候得结合分库分表，把表分散在不同的主数据库中。
    4. 完了吗？NoNoNo，想一想表之间的Join咋办？岂不是要跨数据库和跨服务器join了？简直就是拆东墙补西墙的节奏啊，所以各种中间件就孕育而生了

扩充：现在对**修改表结构**是这么的**解决方案**：
> PS：虽然都是借助工具来操作但原理还是要了解下：`先创建新表，然后旧表中创建一个触发器（处理产生的新数据），然后把一条条数据转移到新表中，接着删除旧表，改名新表`（和旧表名一样）

---

### 1.2.非关系型数据库

引用百科一段`抽象`描述：
> “非关系型数据库，又被称为NoSQL（Not Only SQL )，主要是指非关系型、分布式、不提供ACID的数据库设计模式”

通俗化讲就是：**为了弥补SQL的不足而创建的**（可以逆天NoSQL的优势）
> PS：你可以理解为:NoSQL就是对原来SQL的扩展补充（`NewSQL` = `SQL + NoSQL`）

#### 1.2.1.特性

先说说优势：

1. **易于数据分散**：NoSQL不支持Join，各个数据设计都是独立的，很容易就把数据分散到多个服务器上
2. **轻松支持大量数据写入**：没有那些乱七八糟的关系，横向扩展很轻松
3. **多样性**：NoSQL根据需求拆分成很多种类，使用非常灵活方便

NoSQL的特性就是`CAP`：
> PS：<a href="https://baike.baidu.com/item/CAP原则" target="_blank">CAP</a>是分布式系统需要考虑的三个指标，数据共享只能满足两个而不可兼得：

![CAP](https://img2018.cnblogs.com/blog/1127869/201809/1127869-20180921154758800-192880901.jpg)

1. C：一致性（**C**onsistency）
    1. 所有节点访问同一份最新的数据副本（在分布式系统中的所有数据备份，在同一时刻是否同样的值）
    2. eg：分布式系统里更新公告后，某个用户都应该读取最公告
2. A：可用性（**A**vailability）
    1. 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）
    2. eg：分布式系统里每个操作总能在一定时间内返回结果（挂几个服务器也不影响）
3. P：分区容错性（**P**artition Toleranc）
    1. 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。
    2. eg：分布式系统里，存在网络延迟的情况下依旧可以接受满足一致性和可用性的请求

##### CA

代表：**`传统关系型数据库`**

如果想避免分区容错性问题的发生，一种做法是将所有的数据（与事务相关的）都放在一台机器上。虽然无法100%保证系统不会出错，但不会碰到由分区带来的负面效果（会严重的影响系统的扩展性）

作为一个分布式系统，放弃P，即相当于放弃了分布式，一旦并发性很高，单机服务根本不能承受压力。像很多银行服务，确确实实就是舍弃了P，只用高性能的单台小型机保证服务可用性。（**所有NoSQL数据库都是假设P是存在的**）

##### CP

代表：**`Zookeeper`、`Redis`**（分布式数据库、分布式锁）
> PS：**NoSQL大部分都是CP**

相对于放弃“分区容错性”来说，其反面就是放弃可用性。`一旦遇到分区容错故障，那么受到影响的服务需要等待数据一致`（**等待数据一致性期间系统无法对外提供服务**）

##### AP

代表：**`DNS数据库`**（`IP和域名相互映射的分布式数据库`，联想修改IP后为什么`TTL`需要10分钟左右保证所有解析生效）

![DNS](https://img2018.cnblogs.com/blog/1127869/201809/1127869-20180921161810981-1564173013.png)

放弃强一致，保证最终一致性。所有的`NoSQL`数据库都是介于`CP`和`AP`之间，尽量往`AP`靠
> PS：**传统关系型数据库注重数据一致性，而对NoSQL来说可用性和分区容错性优先级高于数据一致性**

**不同数据对一致性要求是不一样的**，eg：

1. 用户评论、弹幕这些对一致性是不敏感的，很长时间不一致性都不影响用户体验
2. 像商品价格等对一致性有很高要求，容忍度铁定低于10s，就算使用了缓存在订单里面价格也是最新的
    - PS：平时注意下JD商品下面的缓存说明，JD尚且如此，其他的就不用说了

![CAP](https://img2018.cnblogs.com/blog/1127869/201809/1127869-20180921154610361-555022781.png)

#### 1.2.2.代表

常用的已经加粗:

1. **键值数据库**：**Redis**、MemCached...
    - PS：360开发的`pika`（redis的补充）可以解决Redis容量过大的问题
2. **文档数据库**：**MongoDB**、ArangoDB、CouchBase、CouchDB、RavenDB...
    - PS：Python有一款基于json存储的轻量级数据库：`tinydb`
3. 列式数据库：**Cassandra**、**HBase**、BigTable...
    - PS：小米的**Pegasus**计划取代HBase
4. **搜索引擎系**：**Elasticsearch**、Solr、Sphinx...
5. 图形数据库：**Neo4J**、**Flockdb**、**ArangoDB**、OrientDB、Infinite Graph、InfoGrid...
    - PS：基于Redis有一款图形数据库用的也挺多：`RedisGraph`
    - PS：随着Go的兴起，这些图形数据库很火：**Cayley**、`Dgraph`、`Beam`

## 2.MySQL基础

### 2.1.

## 3.SQLServer基础


